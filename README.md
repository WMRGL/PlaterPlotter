
# PlaterPlotter

## Introduction

As part of NHS England’s Whole Genome Sequencing (WGS) Genomic Medicine Service (GMS), our laboratory is responsible for plating all referrals from across England. PlaterPlotter is a piece of software which has been written to enable our laboratory to meet the requirements of this process. The software manages the samples coming from other Genomic Laboratory Hubs (GLHs), applies the predefined plating rules, and handles acknowledgements to and from the National Genomic Informatics Service (NGIS).

## Workflow
Samples are input into the system through ingestion of GEL1004 messages which are sent to us from NGIS. These will be placed into the Input/GEL1004 directory (which is specified in the config file) and the application will pull in new messages from this location when the “Import New” button is pressed on the Rack Notifications tab.

The laboratory staff will then acknowledge physical samples against these lists when they arrive at the plating hub. After the received racks have been acknowledged and the volume checked, a GEL1005 message can be generated by clicking the “Send GEL1005” button next to the consignment. The GEL1005 message will be saved to the Output/GEL1005 directory ready to be uploaded to NGIS.

Acknowledged samples will then move to the Awaiting Sorting tab of the system. Here the samples will be moved from their receiving racks into holding racks into positions with other samples that have been received. At this stage the plating rules set out by NHS England will be applied. The system will instruct the laboratory staff to place the next sample into a holding rack well so that the plating rules are adhered to. Once a holding rack is full enough for plating, the holding racks can be marked as “Ready for Plating”. Any gaps in wells between the samples within the rack will be marked buffer wells.

Holding racks that have been marked as ready for plating they will appear in the Ready to Plate tab. Here the sample positions in the rack will need to be confirmed by performing a rack scan. Once the samples have been confirmed as being in the correct positions a plate can be assigned to the holding rack and the technical team will perform the transfer of samples from the holding rack to the assigned plate.

Once a plate has been assigned, the plates will appear in the Ready to Dispatch tab. From here they can be assigned to a consignment. Once assigned to a consignment the GEL1008 message and consignment manifest will be produced for the plate. The plates that have been assigned to a consignment will appear in the Consignments for Collection tab. Additional plates can be added to a consignment up to the point when it has been marked as collected.



## Installation
(The instructions below are for installation on Ubuntu OS) 

**Installing prerequisites:** Git, Python Virtual Environment, Postgresql
```
sudo apt update
sudo apt-get install git
sudo apt-get install python3-venv
sudo apt install postgresql
sudo systemctl start postgresql.service
```
**Make project directories and clone repository**
```
mkdir -p projects/venvs
cd projects
git clone https://github.com/WMRGL/PlaterPlotter.git
```
**Setup virtal environment and install dependencies**
```
python3 -m venv venvs/platerplotter
source venvs/platerplotter/bin/activate
pip install --upgrade pip
pip install -r PlaterPlotter/requirements.txt
```
**Create local settings file and config file and populate required fields**
```
cp PlaterPlotter/platerplotter/webapp/example_local_settings.py PlaterPlotter/platerplotter/webapp/local_settings.py
cp PlaterPlotter/platerplotter/platerplotter/config/example_config.txt PlaterPlotter/platerplotter/platerplotter/config/config.txt 
```
Open the local_settings.py file and config.txt file and populate the required fields.

**Make required paths from config file and for Test data**
```
cd PlaterPlotter
mkdir <paths_populated_in_config.txt>
mkdir -p TestData/Inbound/GEL1004/processed TestData/Inbound/RackScanner/processed TestData/Outbound/ConsignmentManifests TestData/Outbound/GEL1005 TestData/Outbound/GEL1008 TestData/Outbound/PlatePlots
```
In addition to the paths in the config.txt file, also create the following directories:
```
mkdir <gel1004path>/processed
mkdir <gel1008path>/RF-CT 
mkdir <gel1008path>/RP-CG
mkdir <rack_scanner_path>/processed
```
**Create database**
```
sudo su - postgres
psql
CREATE USER <username_from_local_settings.py> PASSWORD '<password_from_local_settings.py>';
CREATE DATABASE <database_from_local_settings.py> WITH OWNER <username_from_local_settings.py>;
ALTER USER <username_from_local_settings.py> CREATEDB;
\q
exit
```
**Migrate database and create super user**
```
source ../venvs/platerplotter/bin/activate
python platerplotter/manage.py makemigrations platerplotter
python platerplotter/manage.py migrate
python platerplotter/manage.py createsuperuser
```
**Run unit tests**
```
python platerplotter/manage.py test platerplotter
```
Please note the unit tests will generate a large number of ValueError results relating to <User: testuser>. This is normal and is due to the use of easyaudit. A fresh database is created each time the unit tests are run but the user ID does not get assigned to the user until they log in to the application for the first time which means easyaudit cannot track the processes that are occurring correctly for this test user.

**Run application on localhost**
```
python platerplotter/manage.py runserver 0.0.0.0:8000
```
The application can be accessed by navigating to 127.0.0.1:8000 in a browser on the same machine. The super user credentials can be used to log in. Please note, the application functions best when using the Google Chrome browser. 

**Data Visualizations Group**

Only users in the Charts group can view the data visualization, you will need to create a new user group called Charts using this link:
http://127.0.0.1:8000/admin/auth/group/add/

Note: Only users with staff status can add users to the Charts group.
## Branching strategy

- A new development branch must be created for each development
- Commits made to the development brach will be pushed to the GitHub repository for review
- Rebasing to be performed before a pull request
- Once a pull request is made, the reviewers will pull the development branch to their test environment to test the new changes using: `git clone -b <branch> --single-branch <repository url>`
- As the reviewer checks the code they will add suggestions and changes to be made in the following way:
	- Formatting errors or suggestions to improve code's efficiency will be added as comments
	- Raising issues for anything that is fundamentally incorrect
- Changes and reviews will continue in this cycle until all issues are resolved
- The code can then be merged with the master branch and a new tagged release can be created for the update